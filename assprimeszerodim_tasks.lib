////////////////////////////////////////////////////////////////////////////////
version="version assprimeszerodim.lib 3-1-7-0 Sep_2013 ";
category = "Commutative Algebra";
info="
LIBRARY:  assprimeszerodim.lib   associated primes of a zero-dimensional ideal

AUTHORS:  N. Idrees       nazeranjawwad@gmail.com
@*        G. Pfister      pfister@mathematik.uni-kl.de
@*        A. Steenpass    steenpass@mathematik.uni-kl.de
@*        S. Steidel      steidel@mathematik.uni-kl.de

OVERVIEW:

  A library for computing the associated primes and the radical of a
  zero-dimensional ideal in the polynomial ring over the rational numbers,
  Q[x_1,...,x_n], using modular computations.

SEE ALSO: primdec_lib

PROCEDURES:
 zeroRadical(I);       computes the radical of I
 assPrimes(I);         computes the associated primes of I
";

LIB "primdec.lib";
LIB "modstd.lib";
LIB "modstd_tasks.lib";

////////////////////////////////////////////////////////////////////////////////

proc zeroRadical_tasks(ideal I)
"USAGE:  zeroRadical(I); I ideal
ASSUME:  I is zero-dimensional in Q[variables]
RETURN:  the radical of I
EXAMPLE: example zeroRadical; shows an example
"
{
   if (!attrib(I, "isSB"))
   {
      I = modStd_tasks(I);
   }

   ideal F = modular("Assprimeszerodim_tasks::zeroRadP", list(I),
      Modstd_tasks::primeTest_std, Modular::deleteUnluckyPrimes_default,
      Modular::pTest_default, finalTest_zeroRadical);
   // TODO: write deleteUnluckyPrimes_zeroRadical()

   poly f;
   int k;
   int i;
   for(i = nvars(basering); i > 0; i--)
   {
      f = gcd(F[i], diff(F[i], var(i)));
      k = k + deg(f);
      F[i] = F[i]/f;
   }

   if(k == 0)
   {
      return(I);
   }
   else
   {
      return(modStd_tasks(I + F));
   }
}
example
{ "EXAMPLE:";  echo = 2;
   ring R = 0, (x,y), dp;
   ideal I = xy4-2xy2+x, x2-x, y4-2y2+1;
   zeroRadical(I);
}

////////////////////////////////////////////////////////////////////////////////

static proc finalTest_zeroRadical(string command, list args, ideal F)
{
   int i;
   for(i = nvars(basering); i > 0; i--)
   {
      if(reduce(F[i], args[1]) != 0) { return(0); }
   }
   return(1);
}

////////////////////////////////////////////////////////////////////////////////

proc assPrimes_tasks(def I, list #)
"USAGE:  assPrimes(I[, a]); I ideal or module, a int (optional).
         - a = 1: method of Eisenbud/Hunecke/Vasconcelos (default)
         - a = 2: method of Gianni/Trager/Zacharias
         - a = 3: method of Monico
ASSUME:  I is zero-dimensional over Q[variables]
RETURN:  a list of the associated primes of I
EXAMPLE: example assPrimes; shows an example
"
{
   if(typeof(I) != "ideal")
   {
      if(typeof(I) != "module")
      {
         ERROR("The first argument must be of type 'ideal' or 'module'.");
      }
      module M = I;
      kill I;
      ideal I = Ann(M);
      kill M;
   }

   int alg = 1;
   if(size(#) > 0)
   {
      if(size(#) > 1 || typeof(#[1]) != "int")
      {
         ERROR("wrong optional parameter");
      }
      alg = #[1];
      if(alg < 1 || alg > 3)
      {
         ERROR("unknown method");
      }
   }

   if(printlevel >= 10) { "========== Start modStd =========="; }
   if (!attrib(I, "isSB")) {
       I = modStd_tasks(I);
   }
   if(printlevel >= 10) { "=========== End modStd ==========="; }
   int d = vdim(I);
   if(d == -1) { ERROR("Ideal is not zero-dimensional."); }
   if(homog(I) == 1) { return(list(maxideal(1))); }
   poly f = findGen(I);
   if(printlevel >= 9) { "Coordinate change: "+string(f); }

   if(size(f) == nvars(basering))
   {
      int spT;
      if(npars(basering) == 0)
      {
         spT = pTestRad(d,f,I);
      }
      if(printlevel >= 9)
      {
         "pTestRad(d,f,I) = "+string(spT);
      }
      if(!spT)
      {
         if(typeof(attrib(I, "isRad")) == "int")
         {
            if(attrib(I, "isRad") == 0)
            {
               I = zeroRadical_tasks(I);
               I = std(I);
               d = vdim(I);
               f = findGen(I);
            }
         }
         else
         {
            I = zeroRadical_tasks(I);
            I = std(I);
            d = vdim(I);
            f = findGen(I);
         }
      }
   }

   ideal F = modular("Assprimeszerodim_tasks::modpSpecialAlgDep",
      list(I, f, d, alg),
      Modstd_tasks::primeTest_std, Modular::deleteUnluckyPrimes_default,
      pTest_assPrimes, finalTest_assPrimes);

   list result;
   list H = factorize(F[1]);
   int i;
   for(i = size(H[1])-1; i > 0; i--)
   {
      result[i] = I + ideal(quickSubst(H[1][i+1], f, I));
   }
   return(result);
}
example
{ "EXAMPLE:";  echo = 2;
   ring R = 0,(a,b,c,d,e,f),dp;
   ideal I =
   2fb+2ec+d2+a2+a,
   2fc+2ed+2ba+b,
   2fd+e2+2ca+c+b2,
   2fe+2da+d+2cb,
   f2+2ea+e+2db+c2,
   2fa+f+2eb+2dc;
   assPrimes(I);
}

////////////////////////////////////////////////////////////////////////////////

/* Computes a poly F in Q[T] such that
 * <F> = kernel(Q[T] --> basering, T |-> f),
 * T := last variable in the basering.
 */
static proc specialAlgDepEHV(ideal I, poly f)
{
   def R = basering;
   execute("ring QT = ("+charstr(R)+"), "+varstr(R, nvars(R))+", dp;");
   setring(R);
   map phi = QT, f;
   setring QT;
   ideal F = preimage(R, phi, I); // corresponds to std(I, f-T) in dp(n),dp(1)
   setring(R);
   ideal F = imap(QT, F);
   return(F);
}

////////////////////////////////////////////////////////////////////////////////

/* Assume I is zero-dimensional.
 * Computes a poly F in Q[T] such that
 * <F> = kernel(Q[T] --> basering, T |-> f),
 * T := last variable in the basering.
 */
static proc specialAlgDepGTZ(ideal I, poly f)
{
   def R = basering;
   if(nvars(R) > 1)
   {
      def Rlp = changeord(list(list("dp", 1:(nvars(R)-1)), list("dp", 1:1)));
      setring(Rlp);
      poly f = imap(R, f);
      ideal I;
   }
   ideal K = maxideal(1);
   K[nvars(R)] = 2*var(nvars(R))-f;
   map phi = R, K;
   I = phi(I);
   I = std(I);
   ideal F = I[1];
   if(nvars(R) > 1)
   {
      setring(R);
      ideal F = imap(Rlp, F);
   }
   return(F);
}

////////////////////////////////////////////////////////////////////////////////

/* Assume I is zero-dimensional.
 * Computes a poly F in Q[T], the characteristic polynomial of the map
 * basering/I ---> basering/I  defined by the multiplication with f,
 * T := last variable in the basering.
 * In case I is radical, it is the same polynomial as in specialAlgDepEHV.
 */
static proc specialAlgDepMonico(ideal I, poly f, int d)
{
   def R = basering;
   int j;
   matrix M[d][d];
   ideal J = std(I);
   ideal basis = kbase(J);
   poly vars = var(nvars(R));
   for(j = nvars(R)-1; j > 0; j--)
   {
     vars = var(j)*vars;
   }
   for(j = 1; j <= d; j++)
   {
     M[1..d, j] = coeffs(reduce(f*basis[j], J), basis, vars);
   }
   execute("ring QT = ("+charstr(R)+"), "+varstr(R, nvars(R))+", dp;");
   matrix M = imap(R, M);
   ideal F = det(M-var(1)*freemodule(d));
   setring(R);
   ideal F = imap(QT, F);
   return(F);
}

////////////////////////////////////////////////////////////////////////////////

static proc specialTest(int d, poly p, ideal I)
{
//=== computes a poly F in Q[T] such that <F>=kernel(Q[T]--->basering)
//=== mapping T to p and test if d=deg(F)
   def R = basering;
   execute("ring Rhelp = ("+charstr(R)+"), T, dp;");
   setring R;
   map phi = Rhelp,p;
   setring Rhelp;
   ideal F = preimage(R,phi,I);
   int e=deg(F[1]);
   setring R;
   return((e==d));
}

////////////////////////////////////////////////////////////////////////////////

static proc findGen(ideal J, list #)
{
//=== try to find a sparse linear form r such that
//=== vector space dim(basering/J)=deg(F),
//=== F a poly in Q[T] such that <F>=kernel(Q[T]--->basering) mapping T to r
//=== if not found returns a generic (randomly chosen) r
   int d = vdim(J);
   def R = basering;
   int n = nvars(R);
   list rl = ringlist(R);
   if(size(#) > 0) { int p = #[1]; }
   else { int p = prime(random(1000000000,2134567879)); }
   rl[1] = p;
   def @R = ring(rl);
   setring @R;
   ideal J = imap(R,J);
   poly r = var(n);
   int i,k;
   k = specialTest(d,r,J);
   if(!k)
   {
      for(i = 1; i < n; i++)
      {
         k = specialTest(d,r+var(i),J);
         if(k){ r = r + var(i); break; }
      }
   }
   if((!k) && (n > 2))
   {
      for(i = 1; i < n; i++)
      {
         r = r + var(i);
         k = specialTest(d,r,J);
         if(k){ break; }
      }
   }
   setring R;
   poly r = randomLast(100)[nvars(R)];
   if(k){ r = imap(@R,r); }
   return(r);
}

////////////////////////////////////////////////////////////////////////////////

static proc pTestRad(int d, poly p1, ideal I)
{
//=== computes a poly F in Z/q1[T] such that
//===                    <F> = kernel(Z/q1[T]--->Z/q1[vars(basering)])
//=== mapping T to p1 and test if d=deg(squarefreepart(F)), q1 a prime randomly
//=== chosen
//=== If not choose randomly another prime q2 and another linear form p2 and
//=== computes a poly F in Z/q2[T] such that
//===                    <F> = kernel(Z/q2[T]--->Z/q2[vars(basering)])
//=== mapping T to p2 and test if d=deg(squarefreepart(F))
//=== if the test is positive then I is radical
   def R = basering;
   list rl = ringlist(R);
   int q1 = prime(random(100000000,536870912));
   if(typeof(rl[1]) == "int")
   {
       rl[1] = q1;
   }
   else
   {
       rl[1][1] = q1;
   }
   if(npars(R) == 0)
   {
       ring Shelp1 = q1, T, dp;
   }
   else
   {
       execute("ring Shelp1 = (q1,"+parstr(R)+") ,T, dp;");
   }
   setring R;
   def Rhelp1 = ring(rl);
   setring Rhelp1;
   poly p1 = imap(R,p1);
   ideal I = imap(R,I);
   map phi = Shelp1,p1;
   setring Shelp1;
   ideal F = preimage(Rhelp1,phi,I);
   poly f = gcd(F[1],diff(F[1],var(1)));
   int e = deg(F[1]/f);
   setring R;
   if(e != d)
   {
      poly p2 = findGen(I,q1);
      setring Rhelp1;
      poly p2 = imap(R,p2);
      phi = Shelp1,p2;
      setring Shelp1;
      F = preimage(Rhelp1,phi,I);
      f = gcd(F[1],diff(F[1],var(1)));
      e = deg(F[1]/f);
      setring R;
      if(e == d){ return(1); }
      if(e != d)
      {
         int q2 = prime(random(100000000,536870912));
         rl[1] = q2;
         ring Shelp2 = q2,T,dp;
         setring R;
         def Rhelp2 = ring(rl);
         setring Rhelp2;
         poly p1 = imap(R,p1);
         ideal I = imap(R,I);
         map phi = Shelp2,p1;
         setring Shelp2;
         ideal F = preimage(Rhelp2,phi,I);
         poly f = gcd(F[1],diff(F[1],var(1)));
         e = deg(F[1]/f);
         setring R;
         if(e == d){ return(1); }
      }
   }
   return((e==d));
}

////////////////////////////////////////////////////////////////////////////////

/* Computes an ideal F such that ncols(F) = nvars(basering),
 * < F[i] > = (I intersected with K[var(i)]), and F[i] is monic.
 */
static proc zeroRadP(ideal I)
{
   intvec opt = option(get);
   option(redSB);
   I = std(I);
   ideal F = finduni(I);   // F[i] generates I intersected with K[var(i)]
   F = simplify(F, 1);
   option(set, opt);
   return(F);
}

////////////////////////////////////////////////////////////////////////////////

static proc quickSubst(poly h, poly r, ideal I)
{
//=== assume h is in Q[x_n], r is in Q[x_1,...,x_n], computes h(r) mod I
   attrib(I,"isSB",1);
   int n = nvars(basering);
   poly q = 1;
   int i,j,d;
   intvec v;
   list L;
   for(i = 1; i <= size(h); i++)
   {
      L[i] = list(leadcoef(h[i]),leadexp(h[i])[n]);
   }
   d = L[1][2];
   i = 0;
   h = 0;

   while(i <= d)
   {
      if(L[size(L)-j][2] == i)
      {
         h = reduce(h+L[size(L)-j][1]*q,I);
         j++;
      }
      q = reduce(q*r,I);
      i++;
   }
   return(h);
}

////////////////////////////////////////////////////////////////////////////////

static proc modpSpecialAlgDep(ideal I, poly f, int d, int alg)
{
   ideal F;
   if(alg == 1) { F = specialAlgDepEHV(I, f); }
   if(alg == 2) { F = specialAlgDepGTZ(I, f); }
   if(alg == 3) { F = specialAlgDepMonico(I, f, d); }
   F = simplify(F, 1);
   return(F);
}

////////////////////////////////////////////////////////////////////////////////

static proc pTest_assPrimes(string command, list args, ideal F, int p)
{
   def br = basering;
   list lbr = ringlist(br);
   if(typeof(lbr[1]) == "int")
   {
      lbr[1] = p;
   }
   else
   {
      lbr[1][1] = p;
   }
   def rp = ring(lbr);
   setring(rp);
   list args_p = fetch(br, args);
   ideal F = fetch(br, F);
   execute("ideal Fp = "+command+"("
      +Tasks::argsToString("args_p", size(args_p))+");");
   int k = (Fp[1] == F[1]);
   setring br;
   return(k);
}

////////////////////////////////////////////////////////////////////////////////

static proc finalTest_assPrimes(string command, alias list args, ideal F)
{
   F = cleardenom(F[1]);
   if(deg(F[1]) != args[3]) { return(0); }
   if(gcd(F[1], diff(F[1], var(nvars(basering)))) != 1) { return(0); };
   if(quickSubst(F[1], args[2], args[1]) != 0) { return(0); }
   return(1);
}

////////////////////////////////////////////////////////////////////////////////

/*
Examples:
=========

//=== Test for zeroR
ring R = 0,(x,y),dp;
ideal I = xy4-2xy2+x, x2-x, y4-2y2+1;

//=== Cyclic_6
ring R = 0,x(1..6),dp;
ideal I = cyclic(6);

//=== Amrhein
ring R = 0,(a,b,c,d,e,f),dp;
ideal I = 2fb+2ec+d2+a2+a,
          2fc+2ed+2ba+b,
          2fd+e2+2ca+c+b2,
          2fe+2da+d+2cb,
          f2+2ea+e+2db+c2,
          2fa+f+2eb+2dc;

//=== Becker-Niermann
ring R = 0,(x,y,z),dp;
ideal I = x2+xy2z-2xy+y4+y2+z2,
          -x3y2+xy2z+xyz3-2xy+y4,
          -2x2y+xy4+yz4-3;

//=== Roczen
ring R = 0,(a,b,c,d,e,f,g,h,k,o),dp;
ideal I = o+1, k4+k, hk, h4+h, gk, gh, g3+h3+k3+1,
          fk, f4+f, eh, ef, f3h3+e3k3+e3+f3+h3+k3+1,
          e3g+f3g+g, e4+e, dh3+dk3+d, dg, df, de,
          d3+e3+f3+1, e2g2+d2h2+c, f2g2+d2k2+b,
          f2h2+e2k2+a;

//=== FourBodyProblem
//=== 4 bodies with equal masses, before symmetrisation.
//=== We are looking for the real positive solutions
ring R = 0,(B,b,D,d,F,f),dp;
ideal I = (b-d)*(B-D)-2*F+2,
          (b-d)*(B+D-2*F)+2*(B-D),
          (b-d)^2-2*(b+d)+f+1,
          B^2*b^3-1,D^2*d^3-1,F^2*f^3-1;

//=== Reimer_5
ring R = 0,(x,y,z,t,u),dp;
ideal I = 2x2-2y2+2z2-2t2+2u2-1,
          2x3-2y3+2z3-2t3+2u3-1,
          2x4-2y4+2z4-2t4+2u4-1,
          2x5-2y5+2z5-2t5+2u5-1,
          2x6-2y6+2z6-2t6+2u6-1;

//=== ZeroDim.example_12
ring R = 0, (x, y, z), lp;
ideal I = 7xy+x+3yz+4y+2z+10,
          x3+x2y+3xyz+5xy+3x+2y3+6y2z+yz+1,
          3x4+2x2y2+3x2y+4x2z2+xyz+xz2+6y2z+5z4;

//=== ZeroDim.example_27
ring R = 0, (w, x, y, z), lp;
ideal I = -2w2+9wx+9wy-7wz-4w+8x2+9xy-3xz+8x+6y2-7yz+4y-6z2+8z+2,
          3w2-5wx-3wy-6wz+9w+4x2+2xy-2xz+7x+9y2+6yz+5y+7z2+7z+5,
          7w2+5wx+3wy-5wz-5w+2x2+9xy-7xz+4x-4y2-5yz+6y-4z2-9z+2,
          8w2+5wx-4wy+2wz+3w+5x2+2xy-7xz-7x+7y2-8yz-7y+7z2-8z+8;

//=== Cassou_1
ring R = 0, (b,c,d,e), dp;
ideal I = 6b4c3+21b4c2d+15b4cd2+9b4d3+36b4c2+84b4cd+30b4d2+72b4c+84b4d-8b2c2e
          -28b2cde+36b2d2e+48b4-32b2ce-56b2de-144b2c-648b2d-32b2e-288b2-120,
          9b4c4+30b4c3d+39b4c2d2+18b4cd3+72b4c3+180b4c2d+156b4cd2+36b4d3+216b4c2
          +360b4cd+156b4d2-24b2c3e-16b2c2de+16b2cd2e+24b2d3e+288b4c+240b4d
          -144b2c2e+32b2d2e+144b4-432b2c2-720b2cd-432b2d2-288b2ce+16c2e2-32cde2
          +16d2e2-1728b2c-1440b2d-192b2e+64ce2-64de2-1728b2+576ce-576de+64e2
          -240c+1152e+4704,
          -15b2c3e+15b2c2de-90b2c2e+60b2cde-81b2c2+216b2cd-162b2d2-180b2ce
          +60b2de+40c2e2-80cde2+40d2e2-324b2c+432b2d-120b2e+160ce2-160de2-324b2
          +1008ce-1008de+160e2+2016e+5184,
          -4b2c2+4b2cd-3b2d2-16b2c+8b2d-16b2+22ce-22de+44e+261;

================================================================================

The following timings are conducted on an Intel Xeon X5460 with 4 CPUs, 3.16 GHz
each, 64 GB RAM under the Gentoo Linux operating system by using the 32-bit
version of Singular 3-1-1.
The results of the timinings are summarized in the following table where
assPrimes* denotes the parallelized version of the algorithm on 4 CPUs and
 (1) approach of Eisenbud, Hunecke, Vasconcelos (cf. specialAlgDepEHV),
 (2) approach of Gianni, Trager, Zacharias      (cf. specialAlgDepGTZ),
 (3) approach of Monico                         (cf. specialAlgDepMonico).

Example             | minAssGTZ |     assPrimes         assPrimes*
                    |           |  (1)   (2)   (3)   (1)   (2)   (3)
--------------------------------------------------------------------
Cyclic_6            |      5    |    5    10     7     4     7     6
Amrhein             |      1    |    3     3     5     1     2    21
Becker-Niermann     |      -    |    0     0     1     0     0     0
Roczen              |      0    |    3     2     0     2     4     1
FourBodyProblem     |      -    |  139   139   148    96    83    96
Reimer_5            |      -    |  132   128   175    97    70   103
ZeroDim.example_12  |    170    |  125   125   125    67    68    63
ZeroDim.example_27  |     27    |  215   226   215   113   117   108
Cassou_1            |    525    |  112   112   112    56    56    57

minAssGTZ (cf. primdec_lib) runs out of memory for Becker-Niermann,
FourBodyProblem and Reimer_5.

================================================================================

//=== One component at the origin

ring R = 0, (x,y), dp;
poly f1 = (y5 + y4x7 + 2x8);
poly f2 = (y3 + 7x4);
poly f3 = (y7 + 2x12);
poly f = f1*f2*f3 + y19;
ideal I = f, diff(f, x), diff(f, y);

ring R = 0, (x,y), dp;
poly f1 = (y5 + y4x7 + 2x8);
poly f2 = (y3 + 7x4);
poly f3 = (y7 + 2x12);
poly f4 = (y11 + 2x18);
poly f = f1*f2*f3*f4 + y30;
ideal I = f, diff(f, x), diff(f, y);

ring R = 0, (x,y), dp;
poly f1 = (y15 + y14x7 + 2x18);
poly f2 = (y13 + 7x14);
poly f3 = (y17 + 2x22);
poly f = f1*f2*f3 + y49;
ideal I = f, diff(f, x), diff(f, y);

ring R = 0, (x,y), dp;
poly f1 = (y15 + y14x20 + 2x38);
poly f2 = (y19 + 3y17x50 + 7x52);
poly f = f1*f2 + y36;
ideal I = f, diff(f, x), diff(f, y);

//=== Several components

ring R = 0, (x,y), dp;
poly f1 = (y5 + y4x7 + 2x8);
poly f2 = (y13 + 7x14);
poly f = f1*subst(f2, x, x-3, y, y+5);
ideal I = f, diff(f, x), diff(f, y);

ring R = 0, (x,y), dp;
poly f1 = (y5  + y4x7 + 2x8);
poly f2 = (y3 + 7x4);
poly f3 = (y7 + 2x12);
poly f = f1*f2*subst(f3, y, y+5);
ideal I = f, diff(f, x), diff(f, y);

ring R = 0, (x,y), dp;
poly f1 = (y5  + 2x8);
poly f2 = (y3 + 7x4);
poly f3 = (y7 + 2x12);
poly f = f1*subst(f2,x,x-1)*subst(f3, y, y+5);
ideal I = f, diff(f, x), diff(f, y);
*/

